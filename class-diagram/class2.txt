@startuml
abstract class ITEM as "Item" {
- id: int
- label: String
}

note bottom of ITEM
Item is separate from
LineItem because of the
IDs. There can be several
LineItems pertaining to
cookies bought in different
amounts, but there should
be only one cookie Item.
end note

class ITEM_U as "UnitPricedItem" {
- pricePerUnit: float
- kgPerUnit: float
}
ITEM <|-- ITEM_U

class ITEM_W as "WeightPricedItem" {
- pricePerKg: float
}
ITEM <|-- ITEM_W



abstract class LINE_ITEM as "LineItem" {
- policy: PricingPolicy
+ accept(pv: PriceVisitor): float
+ getSubtotalPrice(pv: PriceVisitor): float
+ accept(wv: WeightVisitor): float
}

note top of LINE_ITEM
- Visitable.
- Information expert
on subtotal price
and weight.
Cf GRASP slides 37+
- Dependency injection
for policy for loose
coupling.
Cf GRASP Slides 24-26
end note

class LINE_ITEM_U as "UnitPricedLineItem" {
- item: UnitPricedItem
- quantity: int
+ accept(pv: PriceVisitor): float
+ accept(wv: WeightVisitor): float
}
LINE_ITEM <|-- LINE_ITEM_U
LINE_ITEM_U --> "1" ITEM_U

class LINE_ITEM_W as "WeightPricedLineItem" {
- item: WeightPricedItem
- kgWeight: float
+ accept(pv: PriceVisitor): float
+ accept(wv: WeightVisitor): float
}
LINE_ITEM <|-- LINE_ITEM_W
LINE_ITEM_W --> "1" ITEM_W



interface VISITOR_PRICE as "PriceVisitor" {
+ visit(uli: UnitPricedLineItem): float
+ visit(wli: WeightPricedLineItem): float
}

class VISITOR_PRICE_C as "ConcretePriceVisitor" {
+ visit(uli: UnitPricedLineItem): float
+ visit(wli: WeightPricedLineItem): float
}
VISITOR_PRICE <|-- VISITOR_PRICE_C

interface VISITOR_WEIGHT as "WeightVisitor" {
+ visit(uli: UnitPricedLineItem): float
+ visit(wli: WeightPricedLineItem): float
}

class VISITOR_WEIGHT_C as "ConcreteWeightVisitor" {
+ visit(uli: UnitPricedLineItem): float
+ visit(wli: WeightPricedLineItem): float
}
VISITOR_WEIGHT <|-- VISITOR_WEIGHT_C



interface POLICY as "PricingPolicy" {
+ applyDiscount(price: float): float
}
LINE_ITEM --> "1" POLICY

note bottom of POLICY
R6, R6b:
Strategy pattern
for policies.
Cf Patters slides 20+
end note



class CUSTOMERDATA as "CustomerData" {
- id: int
- firstName: String
- surname: String
- plan: CustomerPlan
- address: Address
}

note left of CUSTOMERDATA
Dependency injection
for plan and address
for loose coupling.
Cf GRASP Slides 24-26
end note

interface PLAN as "CustomerPlan" {
+ applyCartDiscount(total: float): float
+ applyDeliveryDiscount(fee: float): float
+ getAnnualFee(): float
}
CUSTOMERDATA --> "1" PLAN

note bottom of PLAN
R5, R5b, R8b:
- Strategy pattern
- Information expert
on final cart discount.
end note

interface ADDRESS as "Address" {
+ distanceTo(addr: Address): float
}
CUSTOMERDATA --> "1" ADDRESS

note left of ADDRESS
- R8: Information expert
on distance computation.
- Interface for loose
coupling.
end note

class M_ADDRESS as "ManhattanAddress" {
- x: float
- y: float
+ distanceTo(addr: Address): float
}
ADDRESS <|-- M_ADDRESS



class SUPERMARKET as "Supermarket" {
- addr: Address
- items: List<Item>
- plans: List<CustomerPlan>
- policies: List<PricingPolicy>
- customers: List<CustomerData>
}
SUPERMARKET --> "1" ADDRESS
SUPERMARKET --> "1..*" ITEM
SUPERMARKET --> "1..*" PLAN
SUPERMARKET --> "1..*" POLICY
SUPERMARKET --> "0..*" CUSTOMERDATA

note top of SUPERMARKET
Supermarket is a database of
sorts and aggregates items, 
plans, policies and customer
data.
--> Creator pattern: it is
responsible for creating
CustomerData instances
Cf GRASP Slide 32
end note



class REGISTER as "CashRegister" {
- priceVisitor: PriceVisitor
- weightVisitor: WeightVisitor
- cart: List<LineItem>
+ scanLineItem(li: LineItem)
}
REGISTER --> "0..*" LINE_ITEM
REGISTER --> "1" VISITOR_PRICE
REGISTER --> "1" VISITOR_WEIGHT

note top of REGISTER
Visitor pattern to compute
the price of the line items
since they can be priced
differently.
Cf Patterns slides 35+
end note

@enduml