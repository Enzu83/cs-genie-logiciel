@startuml
abstract class ITEM as "Item" {
- id: int
- label: String
- category: String
}

note bottom of ITEM
Item is separate from
LineItem because of the
IDs. There can be several
LineItems pertaining to
cookies bought in different
amounts, but there should
be only one cookie Item.
end note

class ITEM_U as "UnitPricedItem" {
- pricePerUnit: double
- kgPerUnit: double
}
ITEM <|-- ITEM_U

class ITEM_W as "WeightPricedItem" {
- pricePerKg: double
}
ITEM <|-- ITEM_W



abstract class LINE_ITEM as "LineItem" {
+ accept(pv: PriceVisitor): double
+ getSubtotalPrice(pv: PriceVisitor): double
+ accept(wv: WeightVisitor): double
}

note top of LINE_ITEM
- Visitable.
- Information expert
on subtotal price
and weight.
Cf GRASP slides 37+
- Dependency injection
for policy for loose
coupling.
Cf GRASP Slides 24-26
end note

class LINE_ITEM_U as "UnitPricedLineItem" {
- item: UnitPricedItem
- quantity: int
+ accept(pv: PriceVisitor): double
+ accept(wv: WeightVisitor): double
}
LINE_ITEM <|-- LINE_ITEM_U
LINE_ITEM_U --> "1" ITEM_U

class LINE_ITEM_W as "WeightPricedLineItem" {
- item: WeightPricedItem
- kgWeight: double
+ accept(pv: PriceVisitor): double
+ accept(wv: WeightVisitor): double
}
LINE_ITEM <|-- LINE_ITEM_W
LINE_ITEM_W --> "1" ITEM_W

class CART as "ShoppingCart" {
- cart: List<LineItem>
+ addLineItem(li: LineItem)
}
CART --> "0..*" LINE_ITEM



interface VISITOR_PRICE as "PriceVisitor" {
+ visit(uli: UnitPricedLineItem): double
+ visit(wli: WeightPricedLineItem): double
}

class VISITOR_PRICE_C as "ConcretePriceVisitor" {
+ visit(uli: UnitPricedLineItem): double
+ visit(wli: WeightPricedLineItem): double
}
VISITOR_PRICE <|-- VISITOR_PRICE_C

interface VISITOR_WEIGHT as "WeightVisitor" {
+ visit(uli: UnitPricedLineItem): double
+ visit(wli: WeightPricedLineItem): double
}

class VISITOR_WEIGHT_C as "ConcreteWeightVisitor" {
+ visit(uli: UnitPricedLineItem): double
+ visit(wli: WeightPricedLineItem): double
}
VISITOR_WEIGHT <|-- VISITOR_WEIGHT_C



interface POLICY as "PricingPolicy" {
+ applyDiscount(price: double): double
}

note left of POLICY
R6, R6b:
Strategy pattern
for policies.
Cf Patters slides 20+
end note

class FV_POLICY as "FreshVeggiesPolicy" {
+ applyDiscount(price: double): double
}
POLICY <|-- FV_POLICY

class D_POLICY as "DairyPolicy" {
+ applyDiscount(price: double): double
}
POLICY <|-- D_POLICY



class CUSTOMERDATA as "CustomerData" {
- id: int
- firstName: String
- surname: String
- plan: CustomerPlan
- addr: Address
}

note left of CUSTOMERDATA
Dependency injection
for plan and address
for loose coupling.
Cf GRASP Slides 24-26
end note

interface PLAN as "CustomerPlan" {
+ applyCartDiscount(total: double): double
+ applyDeliveryDiscount(fee: double): double
+ getAnnualFee(): double
}
CUSTOMERDATA --> "1" PLAN

note left of PLAN
R5, R5b, R8b:
- Strategy pattern
- Information expert
on final cart discount.
end note

class PLAN_STANDARD as "StandardPlan" {
+ applyCartDiscount(total: double): double
+ applyDeliveryDiscount(fee: double): double
+ getAnnualFee(): double
}
PLAN <|-- PLAN_STANDARD

class PLAN_PRIME as "PrimePlan" {
+ applyCartDiscount(total: double): double
+ applyDeliveryDiscount(fee: double): double
+ getAnnualFee(): double
}
PLAN <|-- PLAN_PRIME

class PLAN_PLAT as "PlatinumPlan" {
+ applyCartDiscount(total: double): double
+ applyDeliveryDiscount(fee: double): double
+ getAnnualFee(): double
}
PLAN <|-- PLAN_PLAT

interface ADDRESS as "Address" {
+ getX(): double
+ getY: double
+ distanceTo(addr: Address): double
}
CUSTOMERDATA --> "1" ADDRESS

note left of ADDRESS
- R8: Information expert
on distance computation.
- Interface for loose
coupling.
end note

class M_ADDRESS as "ManhattanAddress" {
- x: double
- y: double
+ getX(): double
+ getY: double
+ distanceTo(addr: Address): double
}
ADDRESS <|-- M_ADDRESS

class E_ADDRESS as "EuclidAddress" {
- x: double
- y: double
+ getX(): double
+ getY: double
+ distanceTo(addr: Address): double
}
ADDRESS <|-- E_ADDRESS



class SUPERMARKET as "Supermarket" {
- addr: Address
- items: List<Item>
- plans: List<CustomerPlan>
- policies: List<PricingPolicy>
- customers: List<CustomerData>
+ getPolicy(category: String): PricingPolicy
}
SUPERMARKET --> "1" ADDRESS
SUPERMARKET --> "1..*" ITEM
SUPERMARKET --> "1..*" PLAN
SUPERMARKET --> "1..*" POLICY
SUPERMARKET --> "0..*" CUSTOMERDATA

note top of SUPERMARKET
Supermarket is a database of
sorts and aggregates items, 
plans, policies and customer
data.
--> Creator pattern: it is
responsible for creating
CustomerData instances
Cf GRASP Slide 32
end note



class REGISTER as "CashRegister" {
- priceVisitor: PriceVisitor
- weightVisitor: WeightVisitor
+ scanCart(cart: ShoppingCart): double
}
REGISTER --> CART
REGISTER --> "1" VISITOR_PRICE
REGISTER --> "1" VISITOR_WEIGHT

note top of REGISTER
- Visitor pattern to compute
the price of the line items
since they can be priced
differently.
Cf Patterns slides 35+
- scanCart reads the contents
of the cart and displays the
labels and prices as instructed
in the requirements.
It returns the cart's price.
end note
@enduml